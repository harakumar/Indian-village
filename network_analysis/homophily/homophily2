from collections import Counter
import pandas as pd
import numpy as np
# load networkx graph objects G1 and G2
import networkx as nx

data_filepath = '../data/'


def create_df():
    fields = ['village', 'hhid', 'adjmatrix_key', 'religion', 'caste']
    fields_hh = ['hhid', 'adjmatrix_key', 'village']
    df = pd.read_csv(data_filepath + "demographics/individual_characteristics.csv", usecols=fields)
    df_caste = df.groupby(['hhid'])['caste'].agg(pd.Series.mode).to_frame()
    df_caste['hhid'] = df_caste.index
    df_caste.index.names = ['index']
    df_religion = df.groupby(['hhid'])['religion'].agg(pd.Series.mode).to_frame()
    df_religion['hhid'] = df_religion.index
    df_religion.index.names = ['index']
    df_hh = pd.read_csv(data_filepath + "demographics/household_characteristics.csv", usecols=fields_hh)
    df_hh = pd.merge(df_hh, df_caste, on="hhid", how='outer')
    df_hh = pd.merge(df_hh, df_religion, on="hhid", how='outer')
    dfs = list()

    for i in range(1, 78):
        try:
            df_mf = pd.read_csv(data_filepath + "mf_participation/MF" + str(i) + ".csv", header=None,
                                names=['mf_participation'])
            df_hh_village = df_hh[df_hh.village == i]
            df_hh_village = df_hh_village.assign(mf_participation=df_mf.values)
            dfs.append(df_hh_village)
        except:
            print("no village")

    return dfs

# the observed homophily in our network
# measure of homophily is the proportion of edges whose nodes share a characteristic.
def homophily(G, chars, IDs):
    """
    Given a network G, a dict of characteristics chars for node IDs,
    and dict of node IDs for each node in the network,
    find the homophily of the network.
    """
    num_same_ties, num_ties = 0, 0
    print("hello2")
    try:
        for n1 in G.nodes():
            for n2 in G.nodes():
                if n1 > n2:  # do not double-count edges!
                    if IDs[n1] in chars.keys() and IDs[n2] in chars.keys():
                        if G.has_edge(n1, n2):
                            num_ties += 1  # Should `num_ties` be incremented?  What about `num_same_ties`?
                            if any(chars[IDs[n1]]) == any(chars[IDs[n2]]):
                                num_same_ties += 1  # Should `num_ties` be incremented?  What about `num_same_ties`?
    except Exception as e:
        print("exception: " + str(e))
    #print("hello")
    #print("num_ties: " + str(num_ties))
    #print("num_same_ties: " + str(num_same_ties))
    return float(num_same_ties / num_ties)


# measure of homophily will be the proportion of edges in the network whose constituent nodes share that characteristic.
# If characteristics are distributed completely randomly, the probability that
# two nodes x and y share characteristic a is the probability both nodes have characteristic a,
# which is the frequency of a squared.
# total probability that nodes x and y share their characteristic is
# therefore the sum of the frequency of each characteristic in the network
def chance_homophily(chars):
    """
    Computes the chance homophily of a characteristic,
    specified

    """
    chars_counts_dict = Counter(chars.values())
    chars_counts = np.array(list(chars_counts_dict.values()))
    chars_props = chars_counts / sum(chars_counts)
    return sum(chars_props ** 2)

def hh_chars():
    df = pd.read_stata(data_filepath + "demographics/household_characteristics.dta")

    return dict(zip(df.hhid, df.adjmatrix_key))


def map_features(dfs):
    cast_maps = list()
    religion_maps = list()
    for df in dfs:
        caste = dict()
        religion = dict()
        for i, v in df.adjmatrix_key.items():
            if v not in caste:
                caste[v] = df.caste[i]
            if v not in religion:
                religion[v] = df.religion[i]
        cast_maps.append(caste)
        religion_maps.append(religion)

    return cast_maps, religion_maps

def hh_pids():
    pids = list()
    for i in range(1, 78):
        try:
            pid = pd.read_csv(data_filepath + "network_data/adjacency_matrix_keys/key_HH_vilno_" + str(i) + ".csv", dtype=int, header=None)
            pids.append(pid)
        except:
            pass
    return pids

def find_mf_participation_percentage(dfs):
    participation = dict()

    for df in dfs:
        df = df.dropna()
        count = 0
        village = df.village.iloc[0]
        participation[village] = 0
        for p in df.mf_participation:
            count += 1
            if p == 1:
                participation[village] += 1
        participation[village] = participation[village] * 100 / count
    return participation

def find_homophilies():
    dfs = create_df()
    cast_maps, religion_maps = map_features(dfs)
    #pids = hh_pids()
    village_caste_homophily = dict()
    village_religion_homophily = dict()
    for i in range(1, 78):
        try:
            adj = np.loadtxt(data_filepath + "network_data/adjacency_matrices/adj_allVillageRelationships_HH_vilno_" + str(i)+".csv",
                            delimiter=",")
            graph = nx.to_networkx_graph(adj)
            array_pid = dfs[i-1].adjmatrix_key.values
            print("i:" + str(i))
            village_caste_homophily[i] = homophily(graph, cast_maps[i-1], array_pid)
            village_religion_homophily[i] = homophily(graph, religion_maps[i-1], array_pid)
        except:
            pass
    participation = find_mf_participation_percentage(dfs)
    df1 = pd.DataFrame.from_dict([participation])
    df2 = pd.DataFrame.from_dict([village_caste_homophily])
    df3 = pd.DataFrame.from_dict([village_religion_homophily])
    return df1, df2, df3

df1, df2, df3 = find_homophilies()